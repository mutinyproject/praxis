#!/bin/mksh
#
# Riot, a from-source package manager for Mutiny Linux.
#
# Copyright (c) 2016 Kylie McClain <kylie@somasis.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

. "@libdir@/riot/display_functions.sh"
. "@libdir@/riot/extract_functions.sh"
. "@libdir@/riot/version_functions.sh"

die() {
    # shellcheck disable=SC2059
    stderr "$@"
    exit 1
}

get_var() {
    eval "printf '%s' \"\$$1\""
}

array_contains() {
    local item contains="${1}"; shift
    for item in "${@}";do
        case "${item}" in
            "${contains}")
                return 0
            ;;
        esac
    done
    return 1
}

riot_recurse() {
    case "${1}" in
        --test)
            local test="${2}"
            shift 2
        ;;
    esac
    test=${test:--e}
    local oldpwd="${PWD}"
    cd -P -- "$1"
    if [ "${#}" -eq 3 ];then
         [ "${PWD}" = "${3}" ] || return 1
    fi
    for i in ..?* .[!.]* * ; do
        [ "${test}" "${i}" ] && eval "${2} \"\${PWD}/\${i}\""
        [ -d "${i}" ] && riot_recurse --test "${test}" "${PWD}/${i}" "${2}" "${PWD}/${i}"
    done
    cd -P -- "${oldpwd}"
}

lsenv() {
    # last cut removes any suffixes added for array variables
    set | grep '^.*=.*' | cut -d'=' -f1 | cut -d'[' -f1
}

riot_clear_env() {
    local var
    for var in $(lsenv);do
        case "${var}" in
            color_*|riot_*|pkg*|ALLOWED_VARIABLES|METADATA_VARIABLES) ;;
            *)
                if ! array_contains "${var}" "${METADATA_VARAIBLES[@]}" "${ALLOWED_VARIABLES[@]}";then
                    # stderr redirection is used to quiet readonly variables
                    edo unset -v "${var}" >/dev/null 2>&1
                fi
            ;;
        esac
    done

    . "@libdir@/riot/env.sh"
}

type_is_function() { # XXX: on bash and mksh this catches builtins!
    local command
    command=$(command -v "$1")
    [ "${command}" = "$1" ]
}

variable_is_array() {
    if [ -n "${BASH_VERSION}" ];then
        declare -a -p "${1}" >/dev/null 2>&1 && return 0
    elif [ -n "${KSH_VERSION}" ];then
        typeset | grep -Fxq "set -A ${1}" && return 0
    fi
    return 1
}

riot_set_phase() {
    PHASE="$1"
    export PHASE
}

riot_print_phase() {
    printf '%s' "${PHASE}"
}

# shellcheck disable=SC2120
riot_set_phases() {
    local prefix phase
    prefix="$1"
    for phase in ${riot_phases};do
        if type_is_function "${phase}";then
            # if the phase already is set, set the internal caller to simply
            # set ${riot_phase} and then run the phase.
            debug "Using custom phase for ${phase}\n"
            eval "riot_run_${phase}() { riot_set_phase ${phase}; ${phase}; }"
        elif [ -n "${prefix}" ] && type_is_function "${prefix}"_"${phase}";then
            # if a prefix_phase exists, set the internal caller to set
            # ${riot_phase}, and then run the prefix_phase
            debug "Using \"${prefix}_\" prefixed phase for ${phase}\n"
            eval "riot_run_${phase}() { riot_set_phase ${phase}; ${prefix}_${phase}; }"
        else
            # if there's no function to fallback to, the default phases are used.
            debug "Using default phase for ${phase}\n"
            eval "riot_run_${phase}() { riot_set_phase ${phase}; default; }"
        fi
    done
}

riot_initialize() {
    riot_clear_env
    riot_repositories="$(riot_sort_repositories)"
    export riot_repositories

    [ -d "${BUILDDIR}" ] || die "\"${BUILDDIR}\" (the configured builddir) does not exist.\n"
    [ -d "${CACHEDIR}" ] || die "\"${CACHEDIR}\" (the configured cachedir) does not exist.\n"
    [ -d "${PKGDIR}" ] || die "\"${PKGDIR}\" (the configured pkgdir) does not exist.\n"
}

riot_check_repository() {
    local repository required_files file dir
    repository="${1}"
    "${riot_debug}" && debug "Checking \"${repository}\"...\n"

    required_dirs="data packages"
    required_files="data/importance"
    for dir in ${required_dirs};do
        [ -e "${repository}"/"${dir}" ] || die "\"${repository}\": \"${dir}/\" is missing.\n"
        [ -d "${repository}"/"${dir}" ] || die "\"${repository}\": \"${dir}/\" is not readable.\n"
    done
    for file in ${required_files};do
        [ -e "${repository}"/"${file}" ] || die "\"${repository}\": \"${file}\" is missing.\n"
        [ -r "${repository}"/"${file}" ] || die "\"${repository}\": \"${file}\" is not readable.\n"
    done

}

riot_sort_repositories() {
    local repositories repository importance

    for repository in "${PKGDIR}"/*/;do
        repository="${repository%/}" # remove trailing /
        case "${repository}" in
            .*) continue ;; # skip "^\..*" directories, for example ".git"
            *)  riot_check_repository "${repository}" || die "\"${repository}\" failed the sanity check.\n" ;;
        esac
        read -r importance < "${repository}"/data/importance
        repositories="${repositories} ${importance}:${repository}"
    done

    # shellcheck disable=SC2086
    printf '%s\n' ${repositories} | sort -n | cut -d':' -f2-
}

riot_locate_pkg() {
    local repository package version result file candidates
    package="${1}"
    for repository in ${riot_repositories};do
        if [ -d "${repository}"/packages/"${package}" ];then
            for file in "${repository}"/packages/"${package}"/*;do
                file=${file#${repository}/packages/${package}/}
                case "${file}" in
                    ${package}-*.riot)
                        candidates="${file} "
                    ;;
                esac
            done
            if [ -n "${candidates}" ];then
                candidate_num=$(printf '%s\n' ${candidates} | wc -l)
                [ "${candidate_num}" -eq 1 ] && result=$(printf '%s' ${candidates})
                [ "${candidate_num}" -gt 1 ] && result=$(printf '%s\n' ${candidates} | tail -n1)
            fi
        fi
        [ -n "${result}" ] && result="${repository}"/packages/"${package}"/"${result}" && break # stop on first result; collisions are ignored.
    done
    [ -z "${result}" ] && return 1
    printf '%s' "${result}"
}

riot_source_pkg() {
    local pkg file
    pkg="${1}"
    file=$(riot_locate_pkg "${pkg}") || die "Failed to locate \"${pkg}\".\n"
    debug "Using \"%s\"\n" "${file}"

    # variables which a package should always be able to see
    PN="${file##*/}"
    PN="${PN%-*}"

    PV="${file##*/}"
    PV="${PV##*${PN}-}"
    PV="${PV/.riot}"

    REPOSITORY=${file%/packages/${PN}/${file##*/}}
    REPOSITORY="${REPOSITORY##*/}"

    export PN PV REPOSITORY
    export PNV="${PN}-${PV}"
    export HOME="${BUILDDIR}"/build/"${PNV}"
    export BUILD="${HOME}"/build
    export WORK="${BUILD}"/"${PNV}"
    export IMAGE="${HOME}"/image
    export TMPDIR="${HOME}"/tmp

    debug "\"${PNV}\"::${REPOSITORY} found at \"${file}\"\n"
    # shellcheck source=/dev/null
    . "${file}" >/dev/null 2>&1
    if [ "$?" -eq 0 ];then
        return 0
    else
        die "Failed while sourcing \"${file}\".\n"
    fi
}

riot_jobs() {
    local n
    if command -v nproc >/dev/null 2>&1;then
        n=$(nproc)
    elif command -v getconf >/dev/null 2>&1;then
        n=$(getconf _NPROCESSORS_ONLN 2>/dev/null)
        n=${n:-$(getconf NPROCESSORS_ONLN 2>/dev/null)}
    elif [ -r /proc/cpuinfo ];then
        n=$(grep -c '^processor' /proc/cpuinfo)
    fi
    [ -z "${n}" ] && n=1
    printf '%s' "${n}"
}

riot_make_pkg_env() {
    [ -e "${HOME}" ] && edebug rm -rf "${HOME}"
    edebug mkdir -p "${BUILD}" "${IMAGE}" "${TMPDIR}"
    cd "${BUILD}"
}

riot_rm_pkg_env() {
    edebug rm -rf "${BUILD}" "${IMAGE}" "${TMPDIR}"
    [ "${HOME}" = "${BUILDDIR}"/build/"${PNV}" ] && edebug rmdir "${HOME}"
}

riot_merge() {
    local src="${1}" dest="${2}"
    riot_recurse "${src}" "riot_merge_handler \"${src}\" \"${dest}\""
    edebug mkdir -p "${INSTALLDBDIR}"/"${CHOST}"/"${PNV}"/
    edebug mv -f "${TMPDIR}"/riot_file_list "${INSTALLDBDIR}"/"${CHOST}"/"${PNV}"/files
}

riot_merge_handler() {
    local file file_dest src dest type files
    src="${1}"
    dest="${2}"
    shift 2

    touch "${TMPDIR}"/riot_file_list
    for file in "${@}";do
        file_dest=${dest}${file#${src}/}
        printf '%s\n' "${file_dest}" >> "${TMPDIR}"/riot_file_list
        [ -d "${file}" ] && type=d
        [ -f "${file}" ] && type=f
        [ -L "${file}" ] && type=L
        [ -p "${file}" ] && type=p
        [ -S "${file}" ] && type=S
        case "${type}" in
            d) [ -d "${file_dest}" ] || edebug mkdir -p "${file_dest}" ;;
            f) edebug mv -f "${file}" "${file_dest}" ;;
            L)
                if [ -d "${file}" ] && [ -d "${file_dest}" ];then
                    edebug ln -sfn $(readlink "${file}") "${file_dest}"
                elif [ -d "${file}" ] && ! [ -d "${file_dest}" ];then
                    edebug mkdir "${file_dest}"
                elif ! [ -d "${file}" ];then
                    edebug mv -f "${file}" "${file_dest}"
                else
                    die "Not sure how to merge ${file}, type ${type}"
                fi
            ;;
            *)
                die "Unhandled type during merging: ${file}, type ${type}"
            ;;
        esac
    done
}

riot_resolve_dependencies() {
    local dep skip skip_pkgs exec exec_unless_installed
    while [ "${1}" = --skip ];do
        skip_pkgs="${skip_pkgs} ${2}"
        shift 2
    done
    while [ "${1}" = --exec ];do
        exec="${2}"
        shift 2
    done
    if [ "${1}" = --exec-unless-installed ];then
        exec_unless_installed=1
        shift
    fi
    for dep in "${@}";do
        case " ${skip_pkgs} " in
            *" ${dep} "*)
                debug "Skipping ${dep}\n"
                continue
            ;;
            *)
                debug "Resolving ${dep}\n"
            ;;
        esac
        file=$(riot_locate_pkg "${dep}") || die "Failed to locate \"${dep}\".\n"
        "${exec_unless_installed:-${exec}}" "${dep}"
    done
}

riot_check_installed() {
    local pkg
    for pkg in "$@";do
        riot_clear_env
        riot_source_pkg "${pkg}"
        [ -d "${INSTALLDB_DIR}"/"${CHOST}"/"${PNV}" ] || return 1
    done
    return 0
}

riot_pkg_install() {
    local phase pkg
    for pkg in "$@";do
        riot_clear_env
        riot_source_pkg "${pkg}"
        if [ -n ${BUILD_DEPENDENCIES} ] || [ -n ${INSTALL_DEPENDENCIES} ];then
            local BUILD_DEPENDENCIES="${BUILD_DEPENDENCIES}" INSTALL_DEPENDENCIES="${INSTALL_DEPENDENCIES}"
            riot_resolve_dependencies --skip "${pkg}" --exec "riot_pkg_install" --exec-unless-installed ${BUILD_DEPENDENCIES} ${INSTALL_DEPENDENCIES}
            riot_clear_env
            riot_source_pkg "${pkg}"
        fi
        riot_set_phases
        riot_make_pkg_env
        rinfo "Installing ${pkg}"
        for phase in ${riot_install_phases};do
            riot_run_"${phase}" || die "Failed during \"${phase}\" phase.\n"
        done
        riot_rm_pkg_env
        rsuccess "Installed ${pkg}"
    done
}

riot_pkg_info() {
    local pkg var var_arr var_item pretty_name env
    for pkg in "${@}";do
        riot_clear_env
        riot_source_pkg "${pkg}"
        printf "${color_bold}%s${color_red}::%s${color_reset}\n" "${pkg}" "${REPOSITORY}"

        for var in "${METADATA_VARIABLES[@]}";do
            case "${var}" in
                *:*)
                    pretty_name=${var#*:}
                    var=${var%%:*}
                ;;
                *)
                    pretty_name=${var}
                ;;
            esac

            if [ -n "$(get_var ${var})" ];then
                if variable_is_array "${var}";then
                    eval "var_arr=( \"\${${var}[@]}\""
                    if [ "$#" -gt 1 ];then
                        printf "\t${color_bold}%-20s${color_reset}\n" "${pretty_name}"
                        printf "\t\t%-20s\n" "${var_arr[@]}"
                    else
                        printf "\t${color_bold}%-19s${color_reset} %s\n" "${pretty_name}" "$(trim_space "$(get_var ${var})")"
                    fi
                else
                    printf "\t${color_bold}%-19s${color_reset} %s\n" "${pretty_name}" "$(trim_space "$(get_var ${var})")"
                fi
            fi
        done
    done
}

trim_space() {
    printf '%s' "$@" | sed '1,/^./{/./!d};s/^[[:space:]]*//;s/[[:space:]]*$//'
}

# ALLOWED_VARIABLES: variables which should be preserved from any calling environment
ALLOWED_VARIABLES=(CBUILD CHOST CTARGET OPTIND PATH TERM PHASE JOBS BUILDDIR CACHEDIR INSTALLDBDIR PKGDIR)
